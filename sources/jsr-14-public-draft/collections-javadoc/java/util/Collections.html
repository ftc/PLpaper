<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; SunOS 5.8 sun4u) [Netscape]">
   <title>: Class  Collections
</title>
<!--NewPage-->
<!-- Generated by javadoc on Wed May 02 17:23:21 PDT 2001 -->
<link REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</head>
<body bgcolor="#FFFFFF">
<!-- ========== START OF NAVBAR ========== --><a NAME="navbar_top"></a><!-- -->
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td COLSPAN="2" BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><a NAME="navbar_top_firstrow"></a><!-- -->
<table BORDER=0 CELLSPACING=3 CELLPADDING=0 >
<tr ALIGN=CENTER VALIGN=TOP>
<td BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev">&nbsp;<b>Class</b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../overview-tree.html">Tree</a></b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../deprecated-list.html">Deprecated</a></b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../index-all.html">Index</a></b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../help-doc.html">Help</a></b></td>
</tr>
</table>
</td>

<td ALIGN=RIGHT VALIGN=TOP ROWSPAN="3"></td>
</tr>

<tr>
<td BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><font size=-2>&nbsp;<b><a href="Collection.html">PREV
CLASS</a></b>&nbsp;&nbsp; <b><a href="../lang/Comparable.html">NEXT
CLASS</a></b></font></td>

<td BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><font size=-2><b><a href="../../index.html" TARGET="_top">FRAMES</a></b>&nbsp;&nbsp;

<b><a href="Collections.html" TARGET="_top">NO FRAMES</a></b></font></td>
</tr>

<tr>
<td VALIGN=TOP CLASS="NavBarCell3"><font size=-2>SUMMARY: NESTED | <a href="#field_summary">FIELD</a>
| CONSTR | <a href="#method_summary">METHOD</a></font></td>

<td VALIGN=TOP CLASS="NavBarCell3"><font size=-2>DETAIL: <a href="#field_detail">FIELD</a>
| CONSTR | <a href="#method_detail">METHOD</a></font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->
<hr><!-- ======== START OF CLASS DATA ======== -->
<h2>
<font size=-1>java.util<br>
</font>Class Collections</h2>

<pre>java.lang.Object
&nbsp; |
&nbsp; +--<b>java.util.Collections</b></pre>

<hr>
<dl>
<dt>
public class <b>Collections</b></dt>

<dt>
extends java.lang.Object</dt>
</dl>
This class consists exclusively of static methods that operate on or return
collections. It contains polymorphic algorithms that operate on collections,
"wrappers", which return a new collection backed by a specified collection,
and a few other odds and ends.
<p>&nbsp;The documentation for the polymorphic algorithms contained in
this class generally includes a brief description of the <i>implementation</i>.
Such descriptions should be regarded as <i>implementation notes</i>, rather
than parts of the <i>specification</i>. Implementors should feel free to
substitute other algorithms, so long as the specification itself is adhered
to. (For example, the algorithm used by <tt>sort</tt> does not have to
be a mergesort, but it does have to be <i>stable</i>.)
<dl>
<dt>
<b>Since:</b></dt>

<dd>
1.2</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Collection</tt>, <tt>Set</tt>, <tt>List</tt>, <tt>Map</tt></dd>
</dl>

<hr>
<p><!-- ======== NESTED CLASS SUMMARY ======== --><!-- =========== FIELD SUMMARY =========== --><a NAME="field_summary"></a><!-- -->
<table BORDER CELLSPACING=0 CELLPADDING=3 WIDTH="100%" >
<tr BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<td COLSPAN="2"><b><font size=+2>Field Summary</font></b></td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static java.util.List</font></tt></td>

<td><b><tt><a href="Collections.html#EMPTY_LIST">EMPTY_LIST</a></tt></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The empty list
(immutable).</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static java.util.Map</font></tt></td>

<td><b><tt><a href="Collections.html#EMPTY_MAP">EMPTY_MAP</a></tt></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The empty map
(immutable).</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static java.util.Set</font></tt></td>

<td><b><tt><a href="Collections.html#EMPTY_SET">EMPTY_SET</a></tt></b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The empty set
(immutable).</td>
</tr>
</table>
<!-- ======== CONSTRUCTOR SUMMARY ======== --><!-- ========== METHOD SUMMARY =========== --><a NAME="method_summary"></a><!-- -->
<table BORDER CELLSPACING=0 CELLPADDING=3 WIDTH="100%" >
<tr BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<td COLSPAN="2"><b><font size=+2>Method Summary</font></b></td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;S,T>
void&nbsp;</font></tt><S,T xtends S></td>

<td><tt><b><a href="Collections.html#<S,T>copy(java.util.List, java.util.List)">copy</a></b>(java.util.List&lt;S>
dest, java.util.List&lt;T> src)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copies all of
the elements from one list into another.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T,S>
java.util.Map</font></tt></td>

<td><tt><b><a href="Collections.html#<T,S>singletonMap(T, S)">singletonMap</a></b>(T
key, S value)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an immutable
map, mapping only the specified key to the specified value.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T,S>
java.util.Map&lt;T,S></font></tt></td>

<td><tt><b><a href="Collections.html#<T,S>synchronizedMap(java.util.Map)">synchronizedMap</a></b>(java.util.Map&lt;T,S>
m)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a synchronized
(thread-safe) map backed by the specified map.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T,S>
java.util.SortedMap&lt;T,S></font></tt></td>

<td><tt><b><a href="Collections.html#<T,S>synchronizedSortedMap(java.util.SortedMap)">synchronizedSortedMap</a></b>(java.util.SortedMap&lt;T,S>
m)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a synchronized
(thread-safe) sorted map backed by the specified sorted map.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T,S>
java.util.Map&lt;T,S></font></tt></td>

<td><tt><b><a href="Collections.html#<T,S>unmodifiableMap(java.util.Map)">unmodifiableMap</a></b>(java.util.Map&lt;T,S>
m)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an unmodifiable
view of the specified map.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static java.util.SortedMap&lt;T,S></font></tt></td>

<td><tt><b><a href="Collections.html#<T,S>unmodifiableSortedMap(java.util.SortedMap)">unmodifiableSortedMap</a></b>(java.util.SortedMap&lt;T,S>
m)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an unmodifiable
view of the specified sorted map.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> int</font></tt></td>

<td><tt><b><a href="Collections.html#<T>binarySearch(java.util.List, T, java.util.Comparator)">binarySearch</a></b>(java.util.List&lt;T>
list, T key, java.util.Comparator&lt;T> c)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Searches the
specified list for the specified object using the binary search algorithm.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.Enumeration&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>enumeration(java.util.Collection)">enumeration</a></b>(java.util.Collection&lt;T>
c)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an enumeration
over the specified collection.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>fill(java.util.List, T)">fill</a></b>(java.util.List&lt;T>
list, T obj)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Replaces all
of the elements of the specified list with the specified element.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T extends
Comparable&lt;T>> int</font></tt></td>

<td><tt><b><a href="Collections.html#<T>iteratorBinarySearch(java.util.List, java.lang.Object)">iteratorBinarySearch</a></b>(java.util.List&lt;T>
list, T key)</tt></td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> int</font></tt></td>

<td><tt><b><a href="Collections.html#<T>iteratorBinarySearch(java.util.List, T, java.util.Comparator)">iteratorBinarySearch</a></b>(java.util.List&lt;T>
l, T key, java.util.Comparator&lt;T> c)</tt></td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.List&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>list(java.util.Enumeration)">list</a></b>(java.util.Enumeration&lt;T>
e)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an array
list containing the elements returned by the specified enumeration in the
order they are returned by the enumeration.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T extends
Comparable&lt;T>> T</font></tt></td>

<td><tt><b><a href="Collections.html#<T>max(java.util.Collection)">max</a></b>(java.util.Collection&lt;T>
coll)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the
maximum element of the given collection, according to the <i>natural ordering</i>
of its elements.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> T</font></tt></td>

<td><tt><b><a href="Collections.html#<T>max(java.util.Collection, java.util.Comparator)">max</a></b>(java.util.Collection&lt;T>
coll, java.util.Comparator&lt;T> comp)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the
maximum element of the given collection, according to the order induced
by the specified comparator.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T extends
Comparable&lt;T>> T</font></tt></td>

<td><tt><b><a href="Collections.html#<T>min(java.util.Collection)">min</a></b>(java.util.Collection&lt;T>
coll)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the
minimum element of the given collection, according to the <i>natural ordering</i>
of its elements.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static&nbsp; &lt;T>
T</font></tt></td>

<td><tt><b><a href="Collections.html#<T>min(java.util.Collection, java.util.Comparator)">min</a></b>(java.util.Collection&lt;T>
coll, java.util.Comparator&lt;T> comp)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the
minimum element of the given collection, according to the order induced
by the specified comparator.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.List&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>nCopies(int, T)">nCopies</a></b>(int
n, T o)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an immutable
list consisting of <tt>n</tt> copies of the specified object.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> boolean</font></tt></td>

<td><tt><b><a href="Collections.html#<T>replaceAll(java.util.List, T, T)">replaceAll</a></b>(java.util.List&lt;T>
list, T oldVal, T newVal)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Replaces all
occurrences of one specified value in a list with another.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>reverse(java.util.List)">reverse</a></b>(java.util.List&lt;T>
list)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Reverses the
order of the elements in the specified list.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>rotate(java.util.List, int)">rotate</a></b>(java.util.List&lt;T>
list, int distance)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rotates the
elements in the specified list by the specified distance.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>shuffle(java.util.List)">shuffle</a></b>(java.util.List&lt;T>
list)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Randomly permutes
the specified list using a default source of randomness.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>shuffle(java.util.List, java.util.Random)">shuffle</a></b>(java.util.List&lt;T>
list, java.util.Random rnd)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Randomly permute
the specified list using the specified source of randomness.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.List&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>singletonList(T)">singletonList</a></b>(T
o)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an immutable
list containing only the specified object.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T extends
Comparable&lt;T>> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>sort(java.util.List)">sort</a></b>(java.util.List&lt;T>
list)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sorts the specified
list into ascending order, according to the <i>natural ordering</i> of
its elements.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>sort(java.util.List, java.util.Comparator)">sort</a></b>(java.util.List&lt;T>
list, java.util.Comparator&lt;T> c)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sorts the specified
list according to the order induced by the specified comparator.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> void</font></tt></td>

<td><tt><b><a href="Collections.html#<T>swap(java.util.List, int, int)">swap</a></b>(java.util.List&lt;T>
list, int i, int j)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Swaps the elements
at the specified positions in the specified list.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.Collection&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>synchronizedCollection(java.util.Collection)">synchronizedCollection</a></b>(java.util.Collection&lt;T>
c)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a synchronized
(thread-safe) collection backed by the specified collection.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.List&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>synchronizedList(java.util.List)">synchronizedList</a></b>(java.util.List&lt;T>
list)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a synchronized
(thread-safe) list backed by the specified list.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.Set&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>synchronizedSet(java.util.Set)">synchronizedSet</a></b>(java.util.Set&lt;T>
s)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a synchronized
(thread-safe) set backed by the specified set.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.SortedSet&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>synchronizedSortedSet(java.util.SortedSet)">synchronizedSortedSet</a></b>(java.util.SortedSet&lt;T>
s)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a synchronized
(thread-safe) sorted set backed by the specified sorted set.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.List&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>unmodifiableList(java.util.List)">unmodifiableList</a></b>(java.util.List&lt;T>
list)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an unmodifiable
view of the specified list.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.Set&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>unmodifiableSet(java.util.Set)">unmodifiableSet</a></b>(java.util.Set&lt;T>
s)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an unmodifiable
view of the specified set.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.SortedSet&lt;T></font></tt></td>

<td><tt><b><a href="Collections.html#<T>unmodifiableSortedSet(java.util.SortedSet)">unmodifiableSortedSet</a></b>(java.util.SortedSet&lt;T>
s)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an unmodifiable
view of the specified sorted set.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T extends
Comparable&lt;T>> int</font></tt></td>

<td><tt><b><a href="Collections.html#binarySearch(java.util.List, java.lang.Object)">binarySearch</a></b>(java.util.List&lt;T>
list, T key)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Searches the
specified list for the specified object using the binary search algorithm.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T,S>
int</font></tt></td>

<td><tt><b><a href="Collections.html#indexOfSubList(java.util.List, java.util.List)">indexOfSubList</a></b>(java.util.List&lt;S>
source, java.util.List&lt;T> target)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the
starting position of the first occurrence of the specified target list
within the specified source list, or -1 if there is no such occurrence.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T,S>
int</font></tt></td>

<td><tt><b><a href="Collections.html#lastIndexOfSubList(java.util.List, java.util.List)">lastIndexOfSubList</a></b>(java.util.List&lt;S>
source, java.util.List&lt;T> target)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns the
starting position of the last occurrence of the specified target list within
the specified source list, or -1 if there is no such occurrence.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static java.util.Comparator</font></tt></td>

<td><tt><b><a href="Collections.html#reverseOrder()">reverseOrder</a></b>()</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns a comparator
that imposes the reverse of the <i>natural ordering</i> on a collection
of objects that implement the <tt>Comparable</tt> interface.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.Set</font></tt></td>

<td><tt><b><a href="Collections.html#singleton(java.lang.Object)">singleton</a></b>(T
o)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an immutable
set containing only the specified object.</td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td ALIGN=RIGHT VALIGN=TOP WIDTH="1%"><tt><font size=-1>static &lt;T> java.util.Collection</font></tt></td>

<td><tt><b><a href="Collections.html#unmodifiableCollection(java.util.Collection)">unmodifiableCollection</a></b>(java.util.Collection&lt;T>
c)</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns an unmodifiable
view of the specified collection.</td>
</tr>
</table>
<a NAME="methods_inherited_from_class_java.lang.Object"></a><!-- -->
<table BORDER CELLSPACING=0 CELLPADDING=3 WIDTH="100%" >
<tr BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<td><b>Methods inherited from class java.lang.Object</b></td>
</tr>

<tr BGCOLOR="#FFFFFF" CLASS="TableRowColor">
<td><tt>clone, equals, finalize, getClass, hashCode, notify, notifyAll,
toString, wait, wait, wait</tt></td>
</tr>
</table>

<p><!-- ============ FIELD DETAIL =========== --><a NAME="field_detail"></a><!-- -->
<table BORDER CELLSPACING=0 CELLPADDING=3 WIDTH="100%" >
<tr BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<td><b><font size=+2>Field Detail</font></b></td>
</tr>
</table>
<a NAME="EMPTY_SET"></a><!-- -->
<h3>
EMPTY_SET</h3>

<pre>public static final java.util.Set <b>EMPTY_SET</b></pre>

<dl>
<dd>
The empty set (immutable). This set is serializable.</dd>
</dl>

<hr><a NAME="EMPTY_LIST"></a><!-- -->
<h3>
EMPTY_LIST</h3>

<pre>public static final java.util.List <b>EMPTY_LIST</b></pre>

<dl>
<dd>
The empty list (immutable). This list is serializable.</dd>
</dl>

<hr><a NAME="EMPTY_MAP"></a><!-- -->
<h3>
EMPTY_MAP</h3>

<pre>public static final java.util.Map <b>EMPTY_MAP</b></pre>

<dl>
<dd>
The empty map (immutable). This map is serializable.</dd>

<dl>
<dt>
<b>Since:</b></dt>

<dd>
1.3</dd>
</dl>
</dl>
<!-- ========= CONSTRUCTOR DETAIL ======== --><!-- ============ METHOD DETAIL ========== --><a NAME="method_detail"></a><!-- -->
<table BORDER CELLSPACING=0 CELLPADDING=3 WIDTH="100%" >
<tr BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<td><b><font size=+2>Method Detail</font></b></td>
</tr>
</table>
<a NAME="<T>sort(java.util.List)"></a><!-- -->
<h3>
<T>sort</h3>

<pre>public static &lt;T extends Comparable&lt;T>> void <b>sort</b>(java.util.List&lt;T> list)</pre>

<dl>
<dd>
Sorts the specified list into ascending order, according to the <i>natural
ordering</i> of its elements. All elements in the list must implement the
<tt>Comparable</tt>
interface. Furthermore, all elements in the list must be <i>mutually comparable</i>
(that is, <tt>e1.compareTo(e2)</tt> must not throw a <tt>ClassCastException</tt>
for any elements <tt>e1</tt> and
<tt>e2</tt> in the list).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This sort is guaranteed to be <i>stable</i>: equal elements will
not be reordered as a result of the sort.
<p>&nbsp;The specified list must be modifiable, but need not be resizable.
<p>&nbsp;The sorting algorithm is a modified mergesort (in which the merge
is omitted if the highest element in the low sublist is less than the lowest
element in the high sublist). This algorithm offers guaranteed n log(n)
performance, and can approach linear performance on nearly sorted lists.
<p>&nbsp;This implementation dumps the specified list into an array, sorts
the array, and iterates over the list resetting each element from the corresponding
position in the array. This avoids the n<sup>2</sup> log(n) performance
that would result from attempting to sort a linked list in place.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be sorted.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the list contains elements that
are not <i>mutually comparable</i> (for example, strings and integers).</dd>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list's
list-iterator does not support the <tt>set</tt> operation.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>sort(java.util.List, java.util.Comparator)"></a><!-- -->
<h3>
<T>sort</h3>

<pre>public static &lt;T> void <b>sort</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.Comparator&lt;T> c)</pre>

<dl>
<dd>
Sorts the specified list according to the order induced by the specified
comparator. All elements in the list must be <i>mutually comparable</i>
using the specified comparator (that is, <tt>c.compare(e1, e2)</tt> must
not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt> and
<tt>e2</tt>
in the list).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This sort is guaranteed to be <i>stable</i>: equal elements will
not be reordered as a result of the sort.
<p>&nbsp;The sorting algorithm is a modified mergesort (in which the merge
is omitted if the highest element in the low sublist is less than the lowest
element in the high sublist). This algorithm offers guaranteed n log(n)
performance, and can approach linear performance on nearly sorted lists.
<p>&nbsp;The specified list must be modifiable, but need not be resizable.
This implementation dumps the specified list into an array, sorts the array,
and iterates over the list resetting each element from the corresponding
position in the array. This avoids the n<sup>2</sup> log(n) performance
that would result from attempting to sort a linked list in place.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be sorted.</dd>

<dd>
<tt>c</tt> - the comparator to determine the order of the list. A <tt>null</tt>
value indicates that the elements' <i>natural ordering</i> should be used.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the list contains elements that
are not <i>mutually comparable</i> using the specified comparator.</dd>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list's
list-iterator does not support the <tt>set</tt> operation.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparator</tt></dd>
</dl>
</dl>

<hr><a NAME="binarySearch(java.util.List, java.lang.Object)"></a><!-- -->
<h3>
binarySearch</h3>

<pre>public static &lt;T extends Comparable&lt;T>> int <b>binarySearch</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T key)</pre>

<dl>
<dd>
Searches the specified list for the specified object using the binary search
algorithm. The list must be sorted into ascending order according to the
<i>natural
ordering</i> of its elements (as by the <tt>sort(List)</tt> method, above)
prior to making this call. If it is not sorted, the results are undefined.
If the list contains multiple elements equal to the specified object, there
is no guarantee which one will be found.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method runs in log(n) time for a "random access" list (which
provides near-constant-time positional access). If the specified list does
not implement the <tt>RandomAccess</tt> and is large, this method will
do an iterator-based binary search that performs O(n) link traversals and
O(log n) element comparisons.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be searched.</dd>

<dd>
<tt>key</tt> - the key to be searched for.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
index of the search key, if it is contained in the list; otherwise, <tt>(-(<i>insertion
point</i>) - 1)</tt>. The <i>insertion point</i> is defined as the point
at which the key would be inserted into the list: the index of the first
element greater than the key, or <tt>list.size()</tt>, if all elements
in the list are less than the specified key. Note that this guarantees
that the return value will be >= 0 if and only if the key is found.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the list contains elements that
are not <i>mutually comparable</i> (for example, strings and integers),
or the search key in not mutually comparable with the elements of the list.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt>, <tt>#sort(List)</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>iteratorBinarySearch(java.util.List, java.lang.Object)"></a><!-- -->
<h3>
<T>iteratorBinarySearch</h3>

<pre>public static &lt;T extends Comparable&lt;T>> int <b>iteratorBinarySearch</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T key)</pre>

<hr><a NAME="<T>binarySearch(java.util.List, T, java.util.Comparator)"></a><!-- -->
<h3>
<T>binarySearch</h3>

<pre>public static &lt;T> int <b>binarySearch</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.Comparator&lt;T> c)</pre>

<dl>
<dd>
Searches the specified list for the specified object using the binary search
algorithm. The list must be sorted into ascending order according to the
specified comparator (as by the <tt>Sort(List, Comparator)</tt> method,
above), prior to making this call. If it is not sorted, the results are
undefined. If the list contains multiple elements equal to the specified
object, there is no guarantee which one will be found.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method runs in log(n) time for a "random access" list (which
provides near-constant-time positional access). If the specified list does
not implement the <tt>RandomAccess</tt> and is large, this this method
will do an iterator-based binary search that performs O(n) link traversals
and O(log n) element comparisons.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be searched.</dd>

<dd>
<tt>key</tt> - the key to be searched for.</dd>

<dd>
<tt>c</tt> - the comparator by which the list is ordered. A <tt>null</tt>
value indicates that the elements' <i>natural ordering</i> should be used.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
index of the search key, if it is contained in the list; otherwise, <tt>(-(<i>insertion
point</i>) - 1)</tt>. The <i>insertion point</i> is defined as the point
at which the key would be inserted into the list: the index of the first
element greater than the key, or <tt>list.size()</tt>, if all elements
in the list are less than the specified key. Note that this guarantees
that the return value will be >= 0 if and only if the key is found.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the list contains elements that
are not <i>mutually comparable</i> using the specified comparator, or the
search key in not mutually comparable with the elements of the list using
this comparator.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt>, <tt>#sort(List, Comparator)</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>iteratorBinarySearch(java.util.List, T, java.util.Comparator)"></a><!-- -->
<h3>
<T>iteratorBinarySearch</h3>

<pre>public static &lt;T> int <b>iteratorBinarySearch</b>(java.util.List&lt;T> l,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.Comparator&lt;T> c)</pre>

<hr><a NAME="<T>reverse(java.util.List)"></a><!-- -->
<h3>
<T>reverse</h3>

<pre>public static &lt;T> void <b>reverse</b>(java.util.List&lt;T> list)</pre>

<dl>
<dd>
Reverses the order of the elements in the specified list.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method runs in linear time.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>l</tt> - the list whose elements are to be reversed.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list
or its list-iterator does not support the <tt>set</tt> method.</dd>
</dl>
</dl>

<hr><a NAME="<T>shuffle(java.util.List)"></a><!-- -->
<h3>
<T>shuffle</h3>

<pre>public static &lt;T> void <b>shuffle</b>(java.util.List&lt;T> list)</pre>

<dl>
<dd>
Randomly permutes the specified list using a default source of randomness.
All permutations occur with approximately equal likelihood.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The hedge "approximately" is used in the foregoing description
because default source of randomenss is only approximately an unbiased
source of independently chosen bits. If it were a perfect source of randomly
chosen bits, then the algorithm would choose permutations with perfect
uniformity.
<p>&nbsp;This implementation traverses the list backwards, from the last
element up to the second, repeatedly swapping a randomly selected element
into the "current position". Elements are randomly selected from the portion
of the list that runs from the first element to the current position, inclusive.
<p>&nbsp;This method runs in linear time. If the specified list does not
implement the <tt>RandomAccess</tt> interface and is large, this implementation
dumps the specified list into an array before shuffling it, and dumps the
shuffled array back into the list. This avoids the quadratic behavior that
would result from shuffling a "sequential access" list in place.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be shuffled.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list
or its list-iterator does not support the <tt>set</tt> method.</dd>
</dl>
</dl>

<hr><a NAME="<T>shuffle(java.util.List, java.util.Random)"></a><!-- -->
<h3>
<T>shuffle</h3>

<pre>public static &lt;T> void <b>shuffle</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.Random rnd)</pre>

<dl>
<dd>
Randomly permute the specified list using the specified source of randomness.
All permutations occur with equal likelihood assuming that the source of
randomness is fair.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This implementation traverses the list backwards, from the last
element up to the second, repeatedly swapping a randomly selected element
into the "current position". Elements are randomly selected from the portion
of the list that runs from the first element to the current position, inclusive.
<p>&nbsp;This method runs in linear time. If the specified list does not
implement the <tt>RandomAccess</tt> interface and is large, this implementation
dumps the specified list into an array before shuffling it, and dumps the
shuffled array back into the list. This avoids the quadratic behavior that
would result from shuffling a "sequential access" list in place.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be shuffled.</dd>

<dd>
<tt>rnd</tt> - the source of randomness to use to shuffle the list.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list
or its list-iterator does not support the <tt>set</tt> operation.</dd>
</dl>
</dl>

<hr><a NAME="<T>swap(java.util.List, int, int)"></a><!-- -->
<h3>
<T>swap</h3>

<pre>public static &lt;T> void <b>swap</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j)</pre>

<dl>
<dd>
Swaps the elements at the specified positions in the specified list. (If
the specified positions are equal, invoking this method leaves the list
unchanged.)</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - The list in which to swap elements.</dd>

<dd>
<tt>i</tt> - the index of one element to be swapped.</dd>

<dd>
<tt>j</tt> - the index of the other element to be swapped.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.IndexOutOfBoundsException</tt> - if either <tt>i</tt> or
<tt>j</tt>
is out of range (i &lt; 0 || i >= list.size() || j &lt; 0 || j >= list.size()).</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.4</dd>
</dl>
</dl>

<hr><a NAME="<T>fill(java.util.List, T)"></a><!-- -->
<h3>
<T>fill</h3>

<pre>public static &lt;T> void <b>fill</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T obj)</pre>

<dl>
<dd>
Replaces all of the elements of the specified list with the specified element.</dd>

<br>&nbsp;
<p>&nbsp;
<p>This method runs in linear time.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be filled with the specified element.</dd>

<dd>
<tt>o</tt> - The element with which to fill the specified list.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list
or its list-iterator does not support the <tt>set</tt> operation.</dd>
</dl>
</dl>

<hr><a NAME="<S,T>copy(java.util.List, java.util.List)"></a><!-- -->
<h3>
<S,T>copy</h3>

<pre>public static &lt;S,T> void <b>copy</b>(java.util.List&lt;S> dest,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.List&lt;T> src)</pre>

<dl>
<dd>
Copies all of the elements from one list into another. After the operation,
the index of each copied element in the destination list will be identical
to its index in the source list. The destination list must be at least
as long as the source list. If it is longer, the remaining elements in
the destination list are unaffected.</dd>

<br>&nbsp;
<p>&nbsp;
<p>This method runs in linear time.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>dest</tt> - The destination list.</dd>

<dd>
<tt>src</tt> - The source list.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.IndexOutOfBoundsException</tt> - if the destination list
is too small to contain the entire source List.</dd>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the destination list's
list-iterator does not support the <tt>set</tt> operation.</dd>
</dl>
</dl>

<hr><a NAME="<T>min(java.util.Collection)"></a><!-- -->
<h3>
<T>min</h3>

<pre>public static &lt;T extends Comparable&lt;T>> T <b>min</b>(java.util.Collection&lt;T> coll)</pre>

<dl>
<dd>
Returns the minimum element of the given collection, according to the <i>natural
ordering</i> of its elements. All elements in the collection must implement
the <tt>Comparable</tt> interface. Furthermore, all elements in the collection
must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
must not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt>
and <tt>e2</tt> in the collection).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method iterates over the entire collection, hence it requires
time proportional to the size of the collection.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>coll</tt> - the collection whose minimum element is to be determined.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
the minimum element of the given collection, according to the <i>natural
ordering</i> of its elements.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the collection contains elements
that are not <i>mutually comparable</i> (for example, strings and integers).</dd>

<dd>
<tt>NoSuchElementException</tt> - if the collection is empty.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>min(java.util.Collection, java.util.Comparator)"></a><!-- -->
<h3>
<T>min</h3>

<pre>public static &lt;T> T <b>min</b>(java.util.Collection&lt;T> coll,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.Comparator&lt;T> comp)</pre>

<dl>
<dd>
Returns the minimum element of the given collection, according to the order
induced by the specified comparator. All elements in the collection must
be <i>mutually comparable</i> by the specified comparator (that is, <tt>comp.compare(e1,
e2)</tt> must not throw a <tt>ClassCastException</tt> for any elements
<tt>e1</tt>
and <tt>e2</tt> in the collection).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method iterates over the entire collection, hence it requires
time proportional to the size of the collection.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>coll</tt> - the collection whose minimum element is to be determined.</dd>

<dd>
<tt>comp</tt> - the comparator with which to determine the minimum element.
A <tt>null</tt> value indicates that the elements' <i>natural ordering</i>
should be used.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
the minimum element of the given collection, according to the specified
comparator.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the collection contains elements
that are not <i>mutually comparable</i> using the specified comparator.</dd>

<dd>
<tt>NoSuchElementException</tt> - if the collection is empty.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>max(java.util.Collection)"></a><!-- -->
<h3>
<T>max</h3>

<pre>public static &lt;T extends Comparable&lt;T>> T <b>max</b>(java.util.Collection&lt;T> coll)</pre>

<dl>
<dd>
Returns the maximum element of the given collection, according to the <i>natural
ordering</i> of its elements. All elements in the collection must implement
the <tt>Comparable</tt> interface. Furthermore, all elements in the collection
must be <i>mutually comparable</i> (that is, <tt>e1.compareTo(e2)</tt>
must not throw a <tt>ClassCastException</tt> for any elements <tt>e1</tt>
and <tt>e2</tt> in the collection).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method iterates over the entire collection, hence it requires
time proportional to the size of the collection.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>coll</tt> - the collection whose maximum element is to be determined.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
the maximum element of the given collection, according to the <i>natural
ordering</i> of its elements.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the collection contains elements
that are not <i>mutually comparable</i> (for example, strings and integers).</dd>

<dd>
<tt>NoSuchElementException</tt> - if the collection is empty.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>max(java.util.Collection, java.util.Comparator)"></a><!-- -->
<h3>
<T>max</h3>

<pre>public static &lt;T> T <b>max</b>(java.util.Collection&lt;T> coll,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.Comparator&lt;T> comp)</pre>

<dl>
<dd>
Returns the maximum element of the given collection, according to the order
induced by the specified comparator. All elements in the collection must
be <i>mutually comparable</i> by the specified comparator (that is, <tt>comp.compare(e1,
e2)</tt> must not throw a <tt>ClassCastException</tt> for any elements
<tt>e1</tt>
and <tt>e2</tt> in the collection).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;This method iterates over the entire collection, hence it requires
time proportional to the size of the collection.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>coll</tt> - the collection whose maximum element is to be determined.</dd>

<dd>
<tt>comp</tt> - the comparator with which to determine the maximum element.
A <tt>null</tt> value indicates that the elements' <i>natural ordering</i>
should be used.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
the maximum element of the given collection, according to the specified
comparator.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.ClassCastException</tt> - if the collection contains elements
that are not <i>mutually comparable</i> using the specified comparator.</dd>

<dd>
<tt>NoSuchElementException</tt> - if the collection is empty.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>rotate(java.util.List, int)"></a><!-- -->
<h3>
<T>rotate</h3>

<pre>public static &lt;T> void <b>rotate</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int distance)</pre>

<dl>
<dd>
Rotates the elements in the specified list by the specified distance. After
calling this method, the element at index <tt>i</tt> will be the element
previously at index <tt>(i - distance)</tt> mod <tt>list.size()</tt>, for
all values of <tt>i</tt> between <tt>0</tt> and <tt>list.size()-1</tt>,
inclusive. (This method has no effect on the size of the list.)</dd>

<br>&nbsp;
<p>&nbsp;
<p>For example, suppose <tt>list</tt> comprises<tt>[t, a, n, k, s]</tt>.
After invoking <tt>Collections.rotate(list, 4)</tt> (or <tt>Collections.rotate(list,
-1)</tt>), <tt>list</tt> will comprise <tt>[s, t, a, n, k]</tt>.
<p>Note that this method can usefully be applied to sublists to move one
or more elements within a list while preserving the order of the remaining
elements. For example, the following idiom moves the element at index <tt>j</tt>
forward to position <tt>k</tt> (which must be greater than or equal to
<tt>j</tt>):
<pre>&nbsp;&nbsp;&nbsp;&nbsp; Collections.rotate(list.subList(j, k+1), -1);</pre>
To make this concrete, suppose <tt>list</tt> comprises <tt>[a, b, c, d,
e]</tt>. To move the element at index <tt>1</tt> (<tt>b</tt>) forward two
positions, perform the following invocation:
<pre>&nbsp;&nbsp;&nbsp;&nbsp; Collections.rotate(l.subList(1, 4), -1);</pre>
The resulting list is <tt>[a, c, d, b, e]</tt>.
<p>To move more than one element forward, increase the absolute value of
the rotation distance. To move elements backward, use a positive shift
distance.
<p>If the specified list is small or implements the <tt>RandomAccess</tt>
interface, this implementation exchanges the first element into the location
it should go, and then repeatedly exchanges the displaced element into
the location it should go until a displaced element is swapped into the
first element. If necessary, the process is repeated on the second and
successive elements, until the rotation is complete. If the specified list
is large and doesn't implement the <tt>RandomAccess</tt> interface, this
implementation breaks the list into two sublist views around index <tt>-distance
mod size</tt>. Then the <tt>#reverse(List)</tt> method is invoked on each
sublist view, and finally it is invoked on the entire list. For a more
complete description of both algorithms, see Section 2.3 of Jon Bentley's
<i>Programming
Pearls</i> (Addison-Wesley, 1986).
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be rotated.</dd>

<dd>
<tt>distance</tt> - the distance to rotate the list. There are no constraints
on this value; it may be zero, negative, or greater than <tt>list.size()</tt>.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list
or its list-iterator does not support the <tt>set</tt> method.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.4</dd>
</dl>
</dl>

<hr><a NAME="<T>replaceAll(java.util.List, T, T)"></a><!-- -->
<h3>
<T>replaceAll</h3>

<pre>public static &lt;T> boolean <b>replaceAll</b>(java.util.List&lt;T> list,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T oldVal,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T newVal)</pre>

<dl>
<dd>
Replaces all occurrences of one specified value in a list with another.
More formally, replaces with <tt>newVal</tt> each element <tt>e</tt> in
<tt>list</tt>
such that <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt>. (This method
has no effect on the size of the list.)</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list in which replacement is to occur.</dd>

<dd>
<tt>oldVal</tt> - the old value to be replaced.</dd>

<dd>
<tt>newVal</tt> - the new value with which <tt>oldVal</tt> is to be replaced.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
<tt>true</tt> if <tt>list</tt> contained one or more elements <tt>e</tt>
such that <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt>.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.UnsupportedOperationException</tt> - if the specified list
or its list-iterator does not support the <tt>set</tt> method.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.4</dd>
</dl>
</dl>

<hr><a NAME="indexOfSubList(java.util.List, java.util.List)"></a><!-- -->
<h3>
indexOfSubList</h3>

<pre>public static &lt;T,S> int <b>indexOfSubList</b>(java.util.List&lt;S> source,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.List&lt;T> target)</pre>

<dl>
<dd>
Returns the starting position of the first occurrence of the specified
target list within the specified source list, or -1 if there is no such
occurrence. More formally, returns the the lowest index <tt>i</tt> such
that <tt>source.subList(i, i+target.size()).equals(target)</tt>, or -1
if there is no such index. (Returns -1 if <tt>target.size() > source.size()</tt>.)</dd>

<br>&nbsp;
<p>&nbsp;
<p>This implementation uses the "brute force" technique of scanning over
the source list, looking for a match with the target at each location in
turn.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>source</tt> - the list in which to search for the first occurrence
of <tt>target</tt>.</dd>

<dd>
<tt>target</tt> - the list to search for as a subList of <tt>source</tt>.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
the starting position of the first occurrence of the specified target list
within the specified source list, or -1 if there is no such occurrence.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.4</dd>
</dl>
</dl>

<hr><a NAME="lastIndexOfSubList(java.util.List, java.util.List)"></a><!-- -->
<h3>
lastIndexOfSubList</h3>

<pre>public static &lt;T,S> int <b>lastIndexOfSubList</b>(java.util.List&lt;S> source,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java.util.List&lt;T> target)</pre>

<dl>
<dd>
Returns the starting position of the last occurrence of the specified target
list within the specified source list, or -1 if there is no such occurrence.
More formally, returns the the highest index <tt>i</tt> such that <tt>source.subList(i,
i+target.size()).equals(target)</tt>, or -1 if there is no such index.
(Returns -1 if <tt>target.size() > source.size()</tt>.)</dd>

<br>&nbsp;
<p>&nbsp;
<p>This implementation uses the "brute force" technique of iterating over
the source list, looking for a match with the target at each location in
turn.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>source</tt> - the list in which to search for the last occurrence of
<tt>target</tt>.</dd>

<dd>
<tt>target</tt> - the list to search for as a subList of <tt>source</tt>.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
the starting position of the last occurrence of the specified target list
within the specified source list, or -1 if there is no such occurrence.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.4</dd>
</dl>
</dl>

<hr><a NAME="unmodifiableCollection(java.util.Collection)"></a><!-- -->
<h3>
unmodifiableCollection</h3>

<pre>public static &lt;T> java.util.Collection&lt;T> <b>unmodifiableCollection</b>(java.util.Collection&lt;T> c)</pre>

<dl>
<dd>
Returns an unmodifiable view of the specified collection. This method allows
modules to provide users with "read-only" access to internal collections.
Query operations on the returned collection "read through" to the specified
collection, and attempts to modify the returned collection, whether direct
or via its iterator, result in an <tt>UnsupportedOperationException</tt>.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The returned collection does <i>not</i> pass the hashCode and
equals operations through to the backing collection, but relies on
<tt>Object</tt>'s
<tt>equals</tt> and <tt>hashCode</tt> methods. This is necessary to preserve
the contracts of these operations in the case that the backing collection
is a set or a list.
<p>&nbsp;The returned collection will be serializable if the specified
collection is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>c</tt> - the collection for which an unmodifiable view is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an unmodifiable view of the specified collection.</dd>
</dl>
</dl>

<hr><a NAME="<T>unmodifiableSet(java.util.Set)"></a><!-- -->
<h3>
<T>unmodifiableSet</h3>

<pre>public static &lt;T> java.util.Set&lt;T> <b>unmodifiableSet</b>(java.util.Set&lt;T> s)</pre>

<dl>
<dd>
Returns an unmodifiable view of the specified set. This method allows modules
to provide users with "read-only" access to internal sets. Query operations
on the returned set "read through" to the specified set, and attempts to
modify the returned set, whether direct or via its iterator, result in
an <tt>UnsupportedOperationException</tt>.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The returned set will be serializable if the specified set is
serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>s</tt> - the set for which an unmodifiable view is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an unmodifiable view of the specified set.</dd>
</dl>
</dl>

<hr><a NAME="<T>unmodifiableSortedSet(java.util.SortedSet)"></a><!-- -->
<h3>
<T>unmodifiableSortedSet</h3>

<pre>public static &lt;T> java.util.SortedSet&lt;T> <b>unmodifiableSortedSet</b>(java.util.SortedSet&lt;T> s)</pre>

<dl>
<dd>
Returns an unmodifiable view of the specified sorted set. This method allows
modules to provide users with "read-only" access to internal sorted sets.
Query operations on the returned sorted set "read through" to the specified
sorted set. Attempts to modify the returned sorted set, whether direct,
via its iterator, or via its <tt>subSet</tt>, <tt>headSet</tt>, or <tt>tailSet</tt>
views, result in an <tt>UnsupportedOperationException</tt>.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The returned sorted set will be serializable if the specified
sorted set is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>s</tt> - the sorted set for which an unmodifiable view is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an unmodifiable view of the specified sorted set.</dd>
</dl>
</dl>

<hr><a NAME="<T>unmodifiableList(java.util.List)"></a><!-- -->
<h3>
<T>unmodifiableList</h3>

<pre>public static &lt;T> java.util.List&lt;T> <b>unmodifiableList</b>(java.util.List&lt;T> list)</pre>

<dl>
<dd>
Returns an unmodifiable view of the specified list. This method allows
modules to provide users with "read-only" access to internal lists. Query
operations on the returned list "read through" to the specified list, and
attempts to modify the returned list, whether direct or via its iterator,
result in an
<tt>UnsupportedOperationException</tt>.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The returned list will be serializable if the specified list is
serializable. Similarly, the returned list will implement <tt>RandomAccess</tt>
if the specified list does. the
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list for which an unmodifiable view is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an unmodifiable view of the specified list.</dd>
</dl>
</dl>

<hr><a NAME="<T,S>unmodifiableMap(java.util.Map)"></a><!-- -->
<h3>
<T,S>unmodifiableMap</h3>

<pre>public static &lt;T,S> java.util.Map&lt;T,S> <b>unmodifiableMap</b>(java.util.Map&lt;T,S> m)</pre>

<dl>
<dd>
Returns an unmodifiable view of the specified map. This method allows modules
to provide users with "read-only" access to internal maps. Query operations
on the returned map "read through" to the specified map, and attempts to
modify the returned map, whether direct or via its collection views, result
in an <tt>UnsupportedOperationException</tt>.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The returned map will be serializable if the specified map is
serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>m</tt> - the map for which an unmodifiable view is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an unmodifiable view of the specified map.</dd>
</dl>
</dl>

<hr><a NAME="<T,S>unmodifiableSortedMap(java.util.SortedMap)"></a><!-- -->
<h3>
<T,S>unmodifiableSortedMap</h3>

<pre>public static &lt;T,S> java.util.SortedMap&lt;T,S> <b>unmodifiableSortedMap</b>(java.util.SortedMap&lt;T,S> m)</pre>

<dl>
<dd>
Returns an unmodifiable view of the specified sorted map. This method allows
modules to provide users with "read-only" access to internal sorted maps.
Query operations on the returned sorted map "read through" to the specified
sorted map. Attempts to modify the returned sorted map, whether direct,
via its collection views, or via its <tt>subMap</tt>, <tt>headMap</tt>,
or <tt>tailMap</tt> views, result in an <tt>UnsupportedOperationException</tt>.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;The returned sorted map will be serializable if the specified
sorted map is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>m</tt> - the sorted map for which an unmodifiable view is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an unmodifiable view of the specified sorted map.</dd>
</dl>
</dl>

<hr><a NAME="<T>synchronizedCollection(java.util.Collection)"></a><!-- -->
<h3>
<T>synchronizedCollection</h3>

<pre>public static &lt;T> java.util.Collection&lt;T> <b>synchronizedCollection</b>(java.util.Collection&lt;T> c)</pre>

<dl>
<dd>
Returns a synchronized (thread-safe) collection backed by the specified
collection. In order to guarantee serial access, it is critical that <b>all</b>
access to the backing collection is accomplished through the returned collection.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;It is imperative that the user manually synchronize on the returned
collection when iterating over it:
<pre>&nbsp; Collection c = Collections.synchronizedCollection(myCollection);
&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(c) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = c.iterator(); // Must be in the synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
Failure to follow this advice may result in non-deterministic behavior.
<p>The returned collection does <i>not</i> pass the <tt>hashCode</tt> and
<tt>equals</tt>
operations through to the backing collection, but relies on <tt>Object</tt>'s
equals and hashCode methods. This is necessary to preserve the contracts
of these operations in the case that the backing collection is a set or
a list.
<p>&nbsp;The returned collection will be serializable if the specified
collection is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>c</tt> - the collection to be "wrapped" in a synchronized collection.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
a synchronized view of the specified collection.</dd>
</dl>
</dl>

<hr><a NAME="<T>synchronizedSet(java.util.Set)"></a><!-- -->
<h3>
<T>synchronizedSet</h3>

<pre>public static &lt;T> java.util.Set&lt;T> <b>synchronizedSet</b>(java.util.Set&lt;T> s)</pre>

<dl>
<dd>
Returns a synchronized (thread-safe) set backed by the specified set. In
order to guarantee serial access, it is critical that <b>all</b> access
to the backing set is accomplished through the returned set.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;It is imperative that the user manually synchronize on the returned
set when iterating over it:
<pre>&nbsp; Set s = Collections.synchronizedSet(new HashSet());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(s) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = s.iterator(); // Must be in the synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
Failure to follow this advice may result in non-deterministic behavior.
<p>The returned set will be serializable if the specified set is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>s</tt> - the set to be "wrapped" in a synchronized set.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
a synchronized view of the specified set.</dd>
</dl>
</dl>

<hr><a NAME="<T>synchronizedSortedSet(java.util.SortedSet)"></a><!-- -->
<h3>
<T>synchronizedSortedSet</h3>

<pre>public static &lt;T> java.util.SortedSet&lt;T> <b>synchronizedSortedSet</b>(java.util.SortedSet&lt;T> s)</pre>

<dl>
<dd>
Returns a synchronized (thread-safe) sorted set backed by the specified
sorted set. In order to guarantee serial access, it is critical that <b>all</b>
access to the backing sorted set is accomplished through the returned sorted
set (or its views).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;It is imperative that the user manually synchronize on the returned
sorted set when iterating over it or any of its <tt>subSet</tt>,
<tt>headSet</tt>,
or <tt>tailSet</tt> views.
<pre>&nbsp; SortedSet s = Collections.synchronizedSortedSet(new HashSortedSet());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(s) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = s.iterator(); // Must be in the synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
or:
<pre>&nbsp; SortedSet s = Collections.synchronizedSortedSet(new HashSortedSet());
&nbsp; SortedSet s2 = s.headSet(foo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(s) {&nbsp; // Note: s, not s2!!!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = s2.iterator(); // Must be in the synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
Failure to follow this advice may result in non-deterministic behavior.
<p>The returned sorted set will be serializable if the specified sorted
set is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>s</tt> - the sorted set to be "wrapped" in a synchronized sorted set.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
a synchronized view of the specified sorted set.</dd>
</dl>
</dl>

<hr><a NAME="<T>synchronizedList(java.util.List)"></a><!-- -->
<h3>
<T>synchronizedList</h3>

<pre>public static &lt;T> java.util.List&lt;T> <b>synchronizedList</b>(java.util.List&lt;T> list)</pre>

<dl>
<dd>
Returns a synchronized (thread-safe) list backed by the specified list.
In order to guarantee serial access, it is critical that <b>all</b> access
to the backing list is accomplished through the returned list.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;It is imperative that the user manually synchronize on the returned
list when iterating over it:
<pre>&nbsp; List list = Collections.synchronizedList(new ArrayList());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(list) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = list.iterator(); // Must be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
Failure to follow this advice may result in non-deterministic behavior.
<p>The returned list will be serializable if the specified list is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>list</tt> - the list to be "wrapped" in a synchronized list.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
a synchronized view of the specified list.</dd>
</dl>
</dl>

<hr><a NAME="<T,S>synchronizedMap(java.util.Map)"></a><!-- -->
<h3>
<T,S>synchronizedMap</h3>

<pre>public static &lt;T,S> java.util.Map&lt;T,S> <b>synchronizedMap</b>(java.util.Map&lt;T,S> m)</pre>

<dl>
<dd>
Returns a synchronized (thread-safe) map backed by the specified map. In
order to guarantee serial access, it is critical that <b>all</b> access
to the backing map is accomplished through the returned map.</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;It is imperative that the user manually synchronize on the returned
map when iterating over any of its collection views:
<pre>&nbsp; Map m = Collections.synchronizedMap(new HashMap());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; Set s = m.keySet();&nbsp; // Needn't be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(m) {&nbsp; // Synchronizing on m, not s!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = s.iterator(); // Must be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
Failure to follow this advice may result in non-deterministic behavior.
<p>The returned map will be serializable if the specified map is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>m</tt> - the map to be "wrapped" in a synchronized map.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
a synchronized view of the specified map.</dd>
</dl>
</dl>

<hr><a NAME="<T,S>synchronizedSortedMap(java.util.SortedMap)"></a><!-- -->
<h3>
<T,S>synchronizedSortedMap</h3>

<pre>public static &lt;T,S> java.util.SortedMap&lt;T,S> <b>synchronizedSortedMap</b>(java.util.SortedMap&lt;T,S> m)</pre>

<dl>
<dd>
Returns a synchronized (thread-safe) sorted map backed by the specified
sorted map. In order to guarantee serial access, it is critical that <b>all</b>
access to the backing sorted map is accomplished through the returned sorted
map (or its views).</dd>

<br>&nbsp;
<p>&nbsp;
<p>&nbsp;It is imperative that the user manually synchronize on the returned
sorted map when iterating over any of its collection views, or the collections
views of any of its <tt>subMap</tt>, <tt>headMap</tt> or
<tt>tailMap</tt>
views.
<pre>&nbsp; SortedMap m = Collections.synchronizedSortedMap(new HashSortedMap());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; Set s = m.keySet();&nbsp; // Needn't be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(m) {&nbsp; // Synchronizing on m, not s!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = s.iterator(); // Must be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
or:
<pre>&nbsp; SortedMap m = Collections.synchronizedSortedMap(new HashSortedMap());
&nbsp; SortedMap m2 = m.subMap(foo, bar);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; Set s2 = m2.keySet();&nbsp; // Needn't be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp; synchronized(m) {&nbsp; // Synchronizing on m, not m2 or s2!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator i = s.iterator(); // Must be in synchronized block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i.hasNext())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foo(i.next());
&nbsp; }</pre>
Failure to follow this advice may result in non-deterministic behavior.
<p>The returned sorted map will be serializable if the specified sorted
map is serializable.
<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>m</tt> - the sorted map to be "wrapped" in a synchronized sorted map.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
a synchronized view of the specified sorted map.</dd>
</dl>
</dl>

<hr><a NAME="singleton(java.lang.Object)"></a><!-- -->
<h3>
singleton</h3>

<pre>public static &lt;T> java.util.Set&lt;T> <b>singleton</b>(T o)</pre>

<dl>
<dd>
Returns an immutable set containing only the specified object. The returned
set is serializable.</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>o</tt> - the sole object to be stored in the returned set.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an immutable set containing only the specified object.</dd>
</dl>
</dl>

<hr><a NAME="<T>singletonList(T)"></a><!-- -->
<h3>
<T>singletonList</h3>

<pre>public static &lt;T> java.util.List&lt;T> <b>singletonList</b>(T o)</pre>

<dl>
<dd>
Returns an immutable list containing only the specified object. The returned
list is serializable.</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>o</tt> - the sole object to be stored in the returned list.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an immutable list containing only the specified object.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.3</dd>
</dl>
</dl>

<hr><a NAME="<T,S>singletonMap(T, S)"></a><!-- -->
<h3>
<T,S>singletonMap</h3>

<pre>public static &lt;T,S> java.util.Map <b>singletonMap</b>(T key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S value)</pre>

<dl>
<dd>
Returns an immutable map, mapping only the specified key to the specified
value. The returned map is serializable.</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>key</tt> - the sole key to be stored in the returned map.</dd>

<dd>
<tt>value</tt> - the value to which the returned map maps <tt>key</tt>.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an immutable map containing only the specified key-value mapping.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.3</dd>
</dl>
</dl>

<hr><a NAME="<T>nCopies(int, T)"></a><!-- -->
<h3>
<T>nCopies</h3>

<pre>public static &lt;T> java.util.List <b>nCopies</b>(int n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T o)</pre>

<dl>
<dd>
Returns an immutable list consisting of <tt>n</tt> copies of the specified
object. The newly allocated data object is tiny (it contains a single reference
to the data object). This method is useful in combination with the <tt>List.addAll</tt>
method to grow lists. The returned list is serializable.</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>n</tt> - the number of elements in the returned list.</dd>

<dd>
<tt>o</tt> - the element to appear repeatedly in the returned list.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an immutable list consisting of <tt>n</tt> copies of the specified object.</dd>

<dt>
<b>Throws:</b></dt>

<dd>
<tt>java.lang.IllegalArgumentException</tt> - if n &lt; 0.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>List#addAll(Collection)</tt>, <tt>List#addAll(int, Collection)</tt></dd>
</dl>
</dl>

<hr><a NAME="reverseOrder()"></a><!-- -->
<h3>
reverseOrder</h3>

<pre>public static java.util.Comparator <b>reverseOrder</b>()</pre>

<dl>
<dd>
Returns a comparator that imposes the reverse of the <i>natural ordering</i>
on a collection of objects that implement the <tt>Comparable</tt> interface.
(The natural ordering is the ordering imposed by the objects' own <tt>compareTo</tt>
method.) This enables a simple idiom for sorting (or maintaining) collections
(or arrays) of objects that implement the <tt>Comparable</tt> interface
in reverse-natural-order. For example, suppose a is an array of strings.
Then:</dd>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arrays.sort(a, Collections.reverseOrder());</pre>
sorts the array in reverse-lexicographic (alphabetical) order.
<p>&nbsp;The returned comparator is serializable.
<dl>
<dt>
<b>Returns:</b></dt>

<dd>
a comparator that imposes the reverse of the <i>natural ordering</i> on
a collection of objects that implement the <tt>Comparable</tt> interface.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Comparable</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>enumeration(java.util.Collection)"></a><!-- -->
<h3>
<T>enumeration</h3>

<pre>public static &lt;T> java.util.Enumeration&lt;T> <b>enumeration</b>(java.util.Collection&lt;T> c)</pre>

<dl>
<dd>
Returns an enumeration over the specified collection. This provides interoperatbility
with legacy APIs that require an enumeration as input.</dd>

<dl>
<dt>
<b>Parameters:</b></dt>

<dd>
<tt>c</tt> - the collection for which an enumeration is to be returned.</dd>

<dt>
<b>Returns:</b></dt>

<dd>
an enumeration over the specified collection.</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Enumeration</tt></dd>
</dl>
</dl>

<hr><a NAME="<T>list(java.util.Enumeration)"></a><!-- -->
<h3>
<T>list</h3>

<pre>public static &lt;T> java.util.List&lt;T> <b>list</b>(java.util.Enumeration&lt;T> e)</pre>

<dl>
<dd>
Returns an array list containing the elements returned by the specified
enumeration in the order they are returned by the enumeration. This method
provides interoperatbility between legacy APIs that return enumerations
and new APIs that require collections.</dd>

<dl>
<dt>
<b>Returns:</b></dt>

<dd>
an array list containing the elements returned by the specified enumeration.</dd>

<dt>
<b>Since:</b></dt>

<dd>
1.4</dd>

<dt>
<b>See Also:</b></dt>

<dd>
<tt>Enumeration</tt>, <tt>ArrayList</tt></dd>
</dl>
</dl>
<!-- ========= END OF CLASS DATA ========= -->
<hr><!-- ========== START OF NAVBAR ========== --><a NAME="navbar_bottom"></a><!-- -->
<table BORDER=0 CELLSPACING=0 WIDTH="100%" >
<tr>
<td COLSPAN="2" BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><a NAME="navbar_bottom_firstrow"></a><!-- -->
<table BORDER=0 CELLSPACING=3 CELLPADDING=0 >
<tr ALIGN=CENTER VALIGN=TOP>
<td BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev">&nbsp;<b>Class</b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../overview-tree.html">Tree</a></b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../deprecated-list.html">Deprecated</a></b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../index-all.html">Index</a></b></td>

<td BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><b><a href="../../help-doc.html">Help</a></b></td>
</tr>
</table>
</td>

<td ALIGN=RIGHT VALIGN=TOP ROWSPAN="3"></td>
</tr>

<tr>
<td BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><font size=-2>&nbsp;<b><a href="Collection.html">PREV
CLASS</a></b>&nbsp;&nbsp; <b><a href="../lang/Comparable.html">NEXT
CLASS</a></b></font></td>

<td BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><font size=-2><b><a href="../../index.html" TARGET="_top">FRAMES</a></b>&nbsp;&nbsp;

<b><a href="Collections.html" TARGET="_top">NO FRAMES</a></b></font></td>
</tr>

<tr>
<td VALIGN=TOP CLASS="NavBarCell3"><font size=-2>SUMMARY: NESTED | <a href="#field_summary">FIELD</a>
| CONSTR | <a href="#method_summary">METHOD</a></font></td>

<td VALIGN=TOP CLASS="NavBarCell3"><font size=-2>DETAIL: <a href="#field_detail">FIELD</a>
| CONSTR | <a href="#method_detail">METHOD</a></font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->
<hr>
</body>
</html>
